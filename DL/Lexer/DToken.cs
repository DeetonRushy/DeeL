namespace DL.Lexer;

/// <summary>
/// Represents a token generated by <see cref="DLexer"/>.
/// </summary>
public class DToken
{
    /// <summary>
    /// The character literals that were lexed.
    /// </summary>
    public DSpan Lexeme { get; set; } = null!;

    /// <summary>
    /// The type of token this is.
    /// </summary>
    public TokenType Type { get; set; }

    /// <summary>
    /// The line where this token originates from.
    /// </summary>
    public int Line { get; set; } = 0;

    /// <summary>
    /// Optional attached data. This is for if the parser wants some extra information
    /// that the lexer can work out before-hand.
    /// </summary>
    public object? Literal { get; set; } = null;

    /// <summary>
    /// Turn to token into an understandable string.
    /// </summary>
    /// <returns></returns>
    public override string ToString()
    {
        return $"Token({Type}): Span: {{ {Lexeme.Start}, {Lexeme.End} }}, Line: {Line} [{Lexeme.Contents()}]";
    }

    /// <summary>
    /// An invalid token.
    /// </summary>
    public static readonly DToken Bad = new()
    {
        Lexeme = new DSpan { Start = 0, End = 0 },
        Type = TokenType.Invalid,
        Line = -1
    };

    public static readonly DToken Whitespace = new()
    {
        Lexeme = new DSpan { Start = 0, End = 0 },
        Type = TokenType.Whitespace,
        Line = -1
    };
}